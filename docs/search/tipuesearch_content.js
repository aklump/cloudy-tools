var tipuesearch = {"pages":[{"title":"Cloudy Changelog","text":"  1.0.6   BREAKING CHANGE: Renamed $parse_args__option__* to parse_args__options__*.  ","tags":"","url":"CHANGELOG.html"},{"title":"Cloudy","text":"    Summary  A BASH framework, which uses YAML or JSON for your script's configuration and provides a unit testing framework.  Cloudy Boosts the following features:   Clean configuration options (YAML, JSON) for your scripts A BASH Unit Testing framework inspired by PHPUnit Auto-generated help output Support for multilingual localization   Visit https:\/\/aklump.github.io\/cloudy for full documentation.  Quick Start  After installing Cloudy, to write a new script called thunder.sh ...   cd to the directory where you want the script to be created. Type cloudy new thunder.sh and the necessary files\/directories will be created in the current directory. Open thunder.sh, enable logging, and write your code. Open thunder.yml and add some configuration. To learn about the options to use with new type cloudy help new. Refer to the documentation for to learn more.   Using JSON   To work with JSON configuration instead type cloudy new thunder.sh --json.   Requirements   Works with BASH 3 PHP (Used invisibly on the backend for configuration processing; no PHP knowledge is required to use Cloudy.)   Contributing  If you find this project useful... please consider making a donation.  Installation  Installation means downloading this repository to your system.  It contains cloudy_tools.sh which is used to generate new scripts, as well as the cloudy framework.  It is a Cloudy script.  Here is a snippet to clone this repo to a directory on your system $HOME\/opt\/cloudy and create a symlink in $HOME\/bin\/cloudy.  This assumes ~\/bin is in your $PATH variable.  (cd $HOME &amp;&amp; (test -d opt || mkdir opt) &amp;&amp; (test -d bin || mkdir bin) &amp;&amp; cd opt &amp;&amp; (test -d cloudy || git clone https:\/\/github.com\/aklump\/cloudy.git) &amp;&amp; (test -s $HOME\/bin\/cloudy || ln -s $HOME\/opt\/cloudy\/cloudy_installer.sh $HOME\/bin\/cloudy)) &amp;&amp; cloudy   On success you should see something resembling the following:    Usage  Beyond the internal variables the following variables are made available by Cloudy.       varname   description       $ROOT   The directory containing your script.     $SCRIPT   Absolute path to your script.     $CONFIG   Absolute path to the base config file.     $WDIR   The working directory when script was initiated.     $LOGFILE   Absolute path to a log file, if enabled.      Determine your version of BASH with echo $BASH_VERSION   Learn More   Learn more about BASH with the Advanced Bash-Scripting Guide. Checkout The Bash Guide by Maarten Billemont.  ","tags":"","url":"README.html"},{"title":"Tasklist","text":"  - [ ] ld--roadmap: Fix the delay caused by deleting files at beginning of compile. - [ ] ld--todos: a task list item - [ ] ld--todos: a task list item @w-10 - [ ] demos--md_extra: Todo items will get aggregated automatically @w10 - [ ] ld--todos: a task list item @w10 - [ ] ld--todos: a task list item @w10.1  ","tags":"","url":"_tasklist.html"},{"title":"Cloudy Functions","text":"         array_has_value       array_join       array_map       array_sort       array_sort_by_item_length       confirm       date8601       debug       dir_has_files       echo_blue       echo_blue_list       echo_elapsed       echo_error       echo_green       echo_green_list       echo_heading       echo_key_value       echo_list       echo_red       echo_red_highlight       echo_red_list       echo_slim_table       echo_table       echo_title       echo_warning       echo_white       echo_yellow       echo_yellow_highlight       echo_yellow_list       event_dispatch       event_listen       exit_with_cache_clear       exit_with_failure       exit_with_failure_code_only       exit_with_failure_if_config_is_not_path       exit_with_failure_if_empty_config       exit_with_help       exit_with_init       exit_with_success       exit_with_success_code_only       exit_with_success_elapsed       fail       fail_because       function_exists       get_command       get_command_arg       get_config       get_config_as       get_config_keys       get_config_keys_as       get_config_path       get_config_path_as       get_installed       get_option       get_title       get_version       handle_init       has_command       has_command_args       has_failed       has_option       has_options       implement_cloudy_basic       is_installed       list_add_item       list_clear       list_has_items       parse_args       path_extension       path_filename       path_is_absolute       path_mtime       path_relative_to_config_base       path_relative_to_root       path_resolve       string_lower       string_repeat       string_split       string_upper       succeed_because       table_add_row       table_clear       table_has_rows       table_set_header       tempdir       throw       time_local       timestamp       translate       url_add_cache_buster       url_host       validate_input       wait_for_any_key       warn_because       write_log       write_log_alert       write_log_critical       write_log_debug       write_log_dev_warning       write_log_emergency       write_log_error       write_log_info       write_log_notice       write_log_warning     Cloudy Test Functions  The following functions available with: source \"$CLOUDY_ROOT\/inc\/cloudy.testing.sh\"         assert_contains       assert_count       assert_empty       assert_equals       assert_exit_status       assert_false       assert_file_exists       assert_file_not_exists       assert_greater_than       assert_internal_type       assert_less_than       assert_not_contains       assert_not_empty       assert_not_equals       assert_not_internal_type       assert_reg_exp       assert_same       assert_true       create_test_sandbox       delete_test_sandbox       do_tests_in       exit_with_test_results       is_being_tested       mark_test_skipped       test_fail_because     Functions In Depth By Name              array_has_value()     Search $array_has_value__array for a value.                Arguments:                $1: The value to search for in array.                                           array_has_value__array You must provide your array as $array_has_value__array like so: @code   array_has_value__array=(&quot;${some_array_to_search[@]}&quot;)   array_has &quot;tree&quot; &amp;&amp; echo &quot;found tree&quot; @endcode                     array_join()     Echo a string, which is an array joined by a substring.                Arguments:                $1: The string to use to glue the pieces together with.                           Returns 0 if all goes well; 1 on failure.                               array_join__array                     array_map()     Apply a callback to every item in an array and echo new array eval statement.                Arguments:                $1: string The name of the defined array.                           Returns nothing.                               array_map__callback The array_map__callback has to be re-defined for each call of array_map and receives the value of an array item as it&#039;s argument.  The example here expects that user_patterns is an array, already defined.  The array user_patterns is mutated by the eval statement at the end. @code   function array_map__callback {       echo &quot;&lt;h1&gt;$1&lt;\/h1&gt;&quot;   }   declare -a titles=(&quot;The Hobbit&quot; &quot;Charlottes Web&quot;);   eval $(array_map titles) @endcode                     array_sort()     Mutate an array sorting alphabetically.                       array_sort__array                     array_sort_by_item_length()     Mutate an array sorting by the length of each item, short ot long                       array_sort__array @code  array_sort_by_item_length__array=(&quot;september&quot; &quot;five&quot; &quot;three&quot; &quot;on&quot;)  array_sort_by_item_length @endcode                     assert_contains()     Assert that an array contains a value.                Arguments:                $1: The value to search for.               $2: The name of a global variable.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_count()     Assert that an array has a given number of elements.                Arguments:                $1: The expected length.               $2: The name of a global array.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_empty()     Assert that variable by name is empty.                Arguments:                $1: The name of a global variable.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_equals()     Assert that two values are equal in value but not necessarily type.                Arguments:                $1: The expected value.               $2: The value to test.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_exit_status()     Assert a function returns a given exit code.                Arguments:                $:                                            Here are three examples of how to call... @code   array_sort; assert_exit_status 0   $(has_option &#039;name&#039;); assert_exit_status 0   has_option &#039;name&#039; &gt; \/dev\/null; assert_exit_status 0 @endcode                     assert_false()     Assert that a value equals &quot;false&quot; or &quot;FALSE&quot;.                Arguments:                $1: The value to test.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_file_exists()     Assert that a file exists by path.                Arguments:                $1: The filepath of the expected file.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_file_not_exists()     Assert that a file does not exist at path.                Arguments:                $1: The filepath to ensure does not exist.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_greater_than()     Asset one number is greater than another.                Arguments:                $1: The target value.               $2: The number than should be greater than the target.                           Returns 0 if  $2 is &gt; $1                                           assert_internal_type()     Assert that an global variable is of a given type.                Arguments:                $1: The expected type.               $2: The name of a global variable.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_less_than()     Asset one number is less than another.                Arguments:                $1: The target value.               $2: The number than should be less than the target.                           Returns 0 if  $2 is &lt; $1                                           assert_not_contains()     Assert that an array does not contain a value.                Arguments:                $1: The value to search for.               $2: The name of a global variable.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_not_empty()     Assert that variable by name is not empty.                Arguments:                $1: The actual value               $2: A custom message on failure.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_not_equals()     Assert that two values are not the same.                Arguments:                $1: The expected value.               $2: The value to test.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_not_internal_type()     Assert that an global variable is not of a given type.                Arguments:                $1: The expected type.               $2: The name of a global variable.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_reg_exp()     Assert that a value matches a regular expression.                Arguments:                $1: The regular expression.               $2: The value to match against the regexp.                           Returns 0 if assertion is true; 1 otherwise.                                           assert_same()     Assert that two values are equal and of the same type.                Arguments:                $1: The expected value.               $2: The value to test.                           Returns 0 if assertion is true; 1 otherwise.                               @todo is this needed, since bash is untyped?                     assert_true()     Assert that a value equals &quot;true&quot; or &quot;TRUE&quot;.                Arguments:                $1: The value to test.                           Returns 0 if assertion is true; 1 otherwise.                                           confirm()     Prompt for a Y or N confirmation.                Arguments:                $1: The confirmation message                     Options:                    --caution: Use when answering Y requires caution.                   --danger: Use when answering Y is a dangerous thing.                             Returns 0 if the user answers Y; 1 if not.                                           create_test_sandbox()     Create a sandbox for testing.                       Some global variables need to be stashed during testing, such as those to do with the exit system. @see delete_test_sandbox                     date8601()     Return the current datatime in ISO8601 in UTC.                       options -   -c - Remove hyphens and colons for use in a filename                     debug()     Echo the arguments sent to this is an eye-catching manner.                       Call as in the example below for better tracing. @code   debug &quot;Some message to show|$0|$FUNCNAME|$LINENO&quot; @endcode                     delete_test_sandbox()     Remove the sandboxed variables.                       @see create_test_sandbox                     dir_has_files()     Determine if a given directory has any non-hidden files or directories.                Arguments:                $1: The path to a directory to check                           Returns 0 if the path contains non-hidden files directories; 1 if not.                                           do_tests_in()     Perform all tests in a file.                Arguments:                $1: The path to a test file.                           Returns 0 if all tests pass; 1 otherwise.                                           echo_blue()     Echo a string with blue text.                Arguments:                $1: The string to echo.                           Returns nothing.                                           echo_blue_list()     @param $echo_list__array                                   echo_elapsed()     Echo the elapsed time in seconds since the beginning of the script.                                   echo_error()     Echo an error message                Arguments:                $1: The error message.                           Returns nothing.                                           echo_green()     Echo a string with green text.                Arguments:                $1: The string to echo.                           Returns nothing.                                           echo_green_list()     @param $echo_list__array                                   echo_heading()     Echo a heading string.                Arguments:                $1: The heading string.                           Returns nothing.                                           echo_key_value()     $DESCRIPTION                Arguments:                $1: $PARAM$                           Returns 0 if $END$.                                           echo_list()     Echo an array as a bulletted list.                       @param $echo_list__array You must add items to your list first: @code   list_add_item &quot;List item&quot;   echo_list @endcode @see echo_list__array=(&quot;${some_array_to_echo[@]}&quot;)                     echo_red()     Echo a string with red text.                Arguments:                $1: The string to echo.                           Returns nothing.                                           echo_red_highlight()     Echo a string with a red background.                Arguments:                $1: The string to echo.                           Returns nothing.                                           echo_red_list()     @param $echo_list__array                                   echo_slim_table()     Echo a slim version of the table as it&#039;s been defined.                                   echo_table()     Echo the table as it&#039;s been defined.                                   echo_title()     Echo a title string.                Arguments:                $1: The title string.                           Returns nothing.                                           echo_warning()     Echo a warning message                Arguments:                $1: The warning message.                           Returns nothing.                                           echo_white()     Echo a string with white text.                Arguments:                $1: The string to echo.                           Returns nothing.                                           echo_yellow()     Echo a string with yellow text.                Arguments:                $1: The string to echo.                           Returns nothing.                                           echo_yellow_highlight()     Echo a string with a yellow background.                Arguments:                $1: The string to echo.                           Returns nothing.                                           echo_yellow_list()     @param $echo_list__array                                   event_dispatch()     Dispatch that an event has occurred to all listeners.                       Additional arguments beyond $1 are passed on to the listeners.                     event_listen()     Register an event listener.                                   exit_with_cache_clear()     Empties caches in $CLOUDY_ROOT (or other directory if provided) and exits.                                   exit_with_failure()     @option --status=N Optional, set the exit status, a number &gt; 0                                   exit_with_failure_code_only()     Exit without echoing anything with a non-success code.                       @option --status=N Optional, set the exit status, a number &gt; 0                     exit_with_failure_if_config_is_not_path()     Test a global config variable to see if it points to an existing path.                Arguments:                $1: The config path, used by get_config                           Returns 0 if the variable exists and points to a file; exits otherwise with 1.                                           exit_with_failure_if_empty_config()     Checks for a non-empty variable in memory or exist with failure.                       Asks the user to add to their configuration filepath. @param string   This should be the same as passed to get_config, using dot separation. @option as=name   If the configuration has been renamed, send the memory var name --as=varname.                     exit_with_help()     Echo the help screen and exit.                                   exit_with_init()     Performs an initialization (setup default config, etc.) and exits.                       You must set up an init command in your core config file. Then call this function from inside `on_pre_config`, e.g. [[ &quot;$(get_command)&quot; == &quot;init&quot; ]] &amp;&amp; exit_with_init The translation service is not yet bootstrapped in on_pre_config, so if you want to alter the strings printed you can do something like this: if [[ &quot;$(get_command)&quot; == &quot;init&quot; ]]; then     CLOUDY_FAILED=&quot;Initialization failed.&quot;     CLOUDY_SUCCESS=&quot;Initialization complete.&quot;     exit_with_init fi                     exit_with_success()     Echo a success message plus success reasons and exit                Arguments:                $1: The success message to use.                           Returns 0.                                           exit_with_success_code_only()     Exit without echoing anything with a 0 status code.                                   exit_with_success_elapsed()     Echo a success message (with elapsed time) plus success reasons and exit                Arguments:                $1: The success message to use.                           Returns 0.                                           exit_with_test_results()     Echo test results and exit.                                   fail()     Set the exit status to fail with no message.  Does not stop execution.                       Try not to use this because it gives no indication as to why @option --status=N Optional, set the exit status, a number &gt; 0 @see exit_with_failure                     fail_because()     Add a failure message to be shown on exit.                Arguments:                $1: string The reason for the failure.               $2: string A default value if $1 is empty.                           Returns 1 if both $message and $default are empty. 0 otherwise.                               @code   fail_because &quot;$reason&quot; &quot;Some default if $reason is empty&quot; @endcode                     function_exists()     Determine if a function has been defined.                Arguments:                $1: string The name of the function to check.                           Returns 0 if defined; 1 otherwise.                                           get_command()     Echo the command that was used to call the script.                                   get_command_arg()     Return a operation argument by zero-based index key.                Arguments:                $1: int The index of the argument               $2: mixed Optional, default value.                                           As an example see the following code: @code   .\/script.sh action blue apple   get_command --&gt; &quot;action&quot;   get_command_arg 0 --&gt; &quot;blue&quot;   get_command_arg 1 --&gt; &quot;apple&quot; @endcode Returns 0 if found, 2 if using the default.                     get_config()     Get a config path assignment.                       @code   eval $(get_config &#039;path.to.config&#039;) @code When requesting an array you must pass -a as the first argument if there&#039;s any chance that the return value will be empty. @code   eval $(get_config &#039;path.to.string&#039; &#039;default_value&#039;)   eval $(get_config -a &#039;path.to.array&#039; &#039;default_value&#039;) @code                     get_config_as()     Get config path but assign it&#039;s value to a custom variable.                       @code   eval $(get_config_as &#039;title&#039; &#039;path.to.some.title&#039; &#039;default&#039;)   eval $(get_config_as &#039;title&#039; -a &#039;path.to.some.array&#039; ) @code                     get_config_keys()     Echos eval code for the keys of a configuration associative array.                Arguments:                $1: The path to the config item, e.g. &quot;files.private&quot;                           Returns 0 on success.                                           get_config_keys_as()     Echo eval code for keys of a configuration associative array using custom var.                Arguments:                $1: The path to the config item, e.g. &quot;files.private&quot;                           Returns 0 on success.                                           get_config_path()     Echo eval code for paths of a configuration item.                Arguments:                $1: The path to the config item, e.g. &quot;files.private&quot;                     Options:                    -a: If you are expecting an array                             Returns 0 on success.                                           get_config_path_as()     Echo eval code for paths of a configuration item using custom var.                Arguments:                $1: The path to the config item, e.g. &quot;files.private&quot;                     Options:                    -a: If you are expecting an array                             Returns 0 on success.                                           get_installed()     Echo the path to an installed program.                Arguments:                $1: The name of the program you need.                           Returns 0 if .                                           get_option()     Echo the value of a script option, or a default.                Arguments:                $1: The name of the option               $2: A default value if the option was not used.                           Returns 0 if the option was used; 2 if the default is echoed.                                           get_title()     Echo the title as defined in the configuration.                Arguments:                $1: A default value if no title is defined.                           Returns nothing.                                           get_version()     Echos the version of the script.                                   handle_init()     Performs an initialization (setup default config, etc.)                       You must set up an init command in your core config file. Then call this function from inside `on_pre_config`, e.g. [[ &quot;$(get_command)&quot; == &quot;init&quot; ]] &amp;&amp; handle_init ...do your extra work here... exit_with... You should only call this function if you need to do something additional in your init step, where you don&#039;t want to exit.  If not, you should use exit_with_init, instead. The translation service is not yet bootstrapped in on_pre_config, so if you want to alter the strings printed you can do something like this: if [[ &quot;$(get_command)&quot; == &quot;init&quot; ]]; then     CLOUDY_FAILED=&quot;Initialization failed.&quot;     CLOUDY_SUCCESS=&quot;Initialization complete.&quot;     exit_with_init fi                     has_command()     Determine if the script was called with a command.                                   has_command_args()     Determine if there are any arguments for the script &quot;command&quot;.                                   has_failed()     Determine if any failure reasons have been defined yet.                                   has_option()     Determine if the script was called with a given option.                Arguments:                $1: The option to check for.                           Returns 0 if the option was used; 1 if not.                                           has_options()     Determine if any options were used when calling the script.                                   implement_cloudy_basic()     Implement cloudy common commands and options.                       An optional set of commands for all scripts.  This is just the handlers, you must still set up the commands in the config file as usual.                     is_being_tested()     Determine if code is being run from inside a test.                                   is_installed()     Test if a program is installed on the system.                Arguments:                $1: The name of the program to check for.                           Returns 0 if installed; 1 otherwise.                                           list_add_item()     Add an item to the list.                Arguments:                $1: The string to add as a list item.                           Returns nothing.                               echo_list__array                     list_clear()     Remove all items from the list.                                   list_has_items()     Detect if the list has any items.                                   mark_test_skipped()     Mark a single test as skipped                                   parse_args()     Parses arguments into options, args and option values.                       Use this in your my_func function: parse_args &quot;$@&quot; The following variables are generated for: @code   my_func -ab --tree=life do re @endcode                     path_extension()     Return the extension of a file.                                   path_filename()     Return the basename less the extension.                                   path_is_absolute()     Determine if a path is absolute (begins with \/) or not.                Arguments:                $1: The filepath to check                           Returns 0 if absolute; 1 otherwise.                                           path_mtime()     Echo the last modified time of a file.                Arguments:                $1: The path to the the file.                           Returns 1 if the time cannot be determined.                                           path_relative_to_config_base()     Echo a path relative to config_path_base.                       If the path begins with \/ it is unchanged.                     path_relative_to_root()     Expand a relative path using $ROOT as base.                       If the path begins with \/ it is unchanged.                     path_resolve()     Resolve a path to an absolute link; if already absolute, do nothing.                Arguments:                $1: The direname to use if $2 is not absolute               $2: The path to make absolute if not starting with \/                           Returns nothing                                           string_lower()     Echo the lowercase version of a string.                Arguments:                $1: The string to convert to lowercase.                           Returns nothing.                                           string_repeat()     Repeat a string N times.                Arguments:                $1: The string to repeat.               $2: The number of repetitions.                           Returns nothing.                                           string_split()     Split a string by a delimiter.                Arguments:                $1: The delimiter string.                           Returns 0 if .                               string_split__string string_split__array @code  string_split__string=&quot;do&lt;br \/&gt;re&lt;br \/&gt;mi&quot;  string_split &#039;&lt;br \/&gt;&#039; &amp;&amp; local words=(&quot;${string_split__array}&quot;) @endcode                     string_upper()     Echo the uppercase version of a string.                Arguments:                $1: The string to convert to uppercase.                           Returns nothing.                                           succeed_because()     Add a success reason to be shown on exit.                Arguments:                $1: string The reason for the success.               $2: string A default value if $1 is empty.                           Returns 1 if both $message and $default are empty; 0 if successful.                               @code   succeed_because &quot;$reason&quot; &quot;Some default if $reason is empty&quot; @endcode                     table_add_row()     Send any number of arguments, each is a column value for a single row.                                   table_clear()     Clear all rows from the table definition.                                   table_has_rows()     Determine if the table definition has any rows.                                   table_set_header()     Set the column headers for a table.                Arguments:                $@: Each argument is the column header value.                           Returns nothing.                                           tempdir()     Echo a temporary directory filepath.                Arguments:                $1: string An optional directory name to use.                           Returns 0 if successful                               If you do not provide $1 then a new temporary directory is created each time you call tempdir.  If you do provide $1 and call tempdir more than once with the same value for $1, the same directory will be returned each time--a shared directory within the system&#039;s temporary filesystem with the name passed as $1.                     test_fail_because()     Add a failure message to be shown on exit.                Arguments:                $1: string The reason for the failure.               $2: string A default value if $1 is empty.                           Returns 1 if both $message and $default are empty.                               @code   test_fail_because &quot;$reason&quot; &quot;Some default if $reason is empty&quot; @endcode                     throw()     Echo an exception message and exit.                                   time_local()     Echo the current local time as hours\/minutes with optional seconds.                       options -   -s - Include the seconds                     timestamp()     Echo the current unix timestamp.                                   translate()     Echo the translation of a message id into $CLOUDY_LANGUAGE.                Arguments:                $1: The untranslated message.                           Returns 0 if translated; 2 if not translated.                                           url_add_cache_buster()     Add a cache-busting timestamp to an URL and echo the new url.                                   url_host()     Echo the host portion an URL.                                   validate_input()     Validate the CLI input arguments and options.                                   wait_for_any_key()     Prompt the user to read a message and press any key to continue.                Arguments:                $1: The message to show the user.                           Returns nothing                                           warn_because()     Add a warning message to be shown on success exit; not shown on failure exits.                Arguments:                $1: string The warning message.               $2: string A default value if $1 is empty.                           Returns 1 if both $message and $default are empty; 0 if successful.                               @code   warn_because &quot;$reason&quot; &quot;Some default if $reason is empty&quot; @endcode @todo Should this show if a failure exit?                     write_log()     You may include 1 or two arguments; when 2, the first is a log label                                   write_log_alert()     Writes a log message using the alert level.                Arguments:                $@: Any number of strings to write to the log.                           Returns 0 on success or 1 if the log cannot be written to.                                           write_log_critical()     Write to the log with level critical.                Arguments:                $1: The message to write.                           Returns 0 on success.                                           write_log_debug()     Write to the log with level debug.                Arguments:                $1: The message to write.                           Returns 0 on success.                                           write_log_dev_warning()     Log states that should only be thus during development or debugging.                       Adds a &quot;... in dev only message to your warning&quot;                     write_log_emergency()     @link https:\/\/www.php-fig.org\/psr\/psr-3\/                                   write_log_error()     Write to the log with level error.                Arguments:                $1: The message to write.                           Returns 0 on success.                                           write_log_info()     Write to the log with level info.                Arguments:                $1: The message to write.                           Returns 0 on success.                                           write_log_notice()     Write to the log with level notice.                Arguments:                $1: The message to write.                           Returns 0 on success.                                           write_log_warning()     Write to the log with level warning.                Arguments:                $1: The message to write.                           Returns 0 on success.                                   ","tags":"","url":"api.html"},{"title":"This script \"arguments\"","text":"  Cloudy makes it easy to react to script arguments.  For example:  .\/install.sh dev install --tree=blue -abc   Here we have:   The script file install.sh The command command=$(get_command), e.g. dev One argument arg=$(get_arg 0), e.g., install. One value option, tree, param=$(get_param \"tree\"), e.g., blue Three boolean options: a,b,c, has_flag \"a\"   Test if an option was used  has_option b &amp;&amp; echo \"has b option\"   Access an option value  echo \"tree's value is $(get_option tree \"not set\")\"  ","tags":"","url":"arguments.html"},{"title":"Arrays","text":"  How to copy an array  new_array=(\"${old_array[@]}\")   This comes in to play after array-based functions like string_split  string_split__string=\"do&lt;br \/&gt;re&lt;br \/&gt;mi\" string_split '&lt;br \/&gt;' &amp;&amp; local words=(\"${string_split__array}\")   How to copy and array with dynamic name  eval copy=(\\\"\\${$master[@]}\\\")  ","tags":"","url":"arrays.html"},{"title":"Configuration","text":"  Overview  Configuration files are YAML or JSON.  They are connected to your script in one, two, or three ways.   The main configuration file is required and is hardcoded in your script as $CONFIG. Within that file, you may indicate additional configuration files using the key additional_config. Finally, configuration files may be provided dynamically at run time listening to the event compile_config.   If configuration values conflict, those that came later will take prescendence; note: arrays will be merged.  In Depth  The following examples will be shown with YAML.  In the header of your script you will find $CONFIG, this is for the base configuration file, e.g.,      CONFIG=script.example.yml    Set it's value to the path of a supported file to use as configuration, absolute paths must begin with a forward slash, otherwise the path will be taken relative to the directory containing the script, i.e., $(dirname your_cloudy_script.sh) You may add additional configuration files by adding something like following in the YAML of the base configuration file.  additional_config:   - _install.local.yml  Thirdly, you may provide configuration paths at run-time:  function on_compile_config() {     echo \"some\/other\/config.yml\" }  You may have any number of configuration files. Consider limited file permissions on your configuration files; e.g. chmod go-rwx.   Using Config  Scalars  To get a configuration value you will use the get_config function.  The following example is the contents of an imaginary config.yml:  perms:   user: aklump   group: apache   files: 640   directories: 750   To access the perms group scalar value do one of the following:  eval $(get_config \"perms.group\" \"staff\") # [ perms_group = 'apache' ]    Notice the dot separation to denote parent\/child. The second argument is a default value, e.g., staff.   You can also assign to a different variable like this:  eval $(get_config_as \"group\" \"perms.group\" \"staff\")  # [ group = 'apache' ]   Arrays  Arrays are handled differntly depending upon a few things: if the config key points to a multi-dimensional array, an single-level associative array, or an single-level indexed array.  For examples turn to the following configuration YAML:  user:   images:     tags:     - nature     - space     - religion     types:     - jpg     - png   Let's see what $(get_config -a 'user.images.tags') returns us:  When the config key points to an array get_config echos a string ready for eval, which generates a nice set of BASH vars containing the values of perms, e.g.,  eval $(get_config perms) echo $perms_user echo $perms_group echo $perms_files echo $perms_directories   If the config key points to an indexed array, e.g., ....  Non-Scalars Keys  In a more complex configuration like the following, you might want to get the array keys, in this case all the \"operations\"; do so with get_config.  Our example will echo a string like this: declare -a config_keys=(\"_default\" \"help\" \"new\")  operations:   _default: help   help:     help: Display this help screen   new:     help: Create new Cloudy script file in the current directory     options:       config:         help: Set the basename of the config file.       force:         aliases: [f]         help: Force the overwrite of an existin file.   This is a usage example:  eval $(get_config_keys \"commands\")  ${config_keys[0]} == \"_default\" ${config_keys[1]} == \"help\" ${config_keys[2]} == \"new\"   Filepaths  Configuration values which are filepaths can be added to the YAML as relative paths:  webroot: ..\/web path_to_binaries: . public_files: ..\/web\/sites\/default\/files   Then when you access the configuration use get_config_path, e.g.,  eval $(get_config_path \"webroot\")   The value of $webroot will be an an absolute filepath.  How are relative filepaths made absolute?   By default $ROOT is used as the basepath, which is the directory that contains your Cloudy script. You can alter this behavior by setting the configuration variable as config_path_base with a value, which is either an absolute path, or a relative path, relative to $ROOT.  Both of the following are valid values:  # relative to $ROOT config_path_base: ..\/..\/..  # or using an absolute path... config_path_base: \/Users\/aklump\/config    Pro Tip  If you put a stack of paths under a single key, like so:  files: - webroot: ..\/web - bin: . - public: ..\/web\/sites\/default\/files   You can import all of them with one line like this:  eval $(get_config_path \"files\")   And you will have access to:  $files_webroot         $files_bin         $files_public   If the yaml is an indexed array like so:  files: - ..\/web - . - ..\/web\/sites\/default\/files   You have one extra step of variable assignment.  eval $(get_config_path \"writeable_directories\") writeable_directories=($_config_values[@]})      ","tags":"","url":"configuration.html"},{"title":"Cloudy Conventions","text":"  Cloudy has some opinions about how to write code, this page reveals them.  General   Functions that begin with _cloudy should be considered private and never called by your script.  They may change in future versions. All functions listed in cloudy.sh comprise the public API and will not change across minor version changes.   Naming   Function names should be readable and intuitive, e.g., exit_with_success is better than success_exit Function names should start with a verb if applicable, unless they are grouped by category, e.g. array_join is fine because stack is the common group; join is the verb.   Boolean  Even though BASH doesn't distinguish between (bool) \"true\" and (string) \"true\", you should indicate your intention by not using quotes for boolean value.  my_var=true my_var=false   Do not do the following when your intention is boolean:  my_var=\"true\" my_var=\"false\"   Likewise to test for true do like this, which again, omits any quotes around true.  [[ \"$my_var\" = true ]]   Functions   For getters when echoing a default value, return 2   Functions that operate on arrays  When a function needs to manipulate an array, the array should be assigned to a global variable, the name of which is the function with __array added to the end, e.g.,  function array_join() {     local glue=$1     local string     string=$(printf \"%s$glue\" \"${array_join__array[@]}\") &amp;&amp; string=${string%$glue} || return 1     echo $string     return 0 }   And here is the usage  array_join__array=(\"${_config_values[@]}\") local options=\"-$(array_join \", -\"), --${option}\"       However, if a single function operates on more than one array, then the suffix should be modified as necessary.  Look at _cloudy_parse_option_arguments for a good example.  You still want the suffix to begin with two underscores.  Functions that return an array  The same naming conventions apply, if the function has to \"return\" an array, which, in BASH means it sets or mutates a global array.  Beware of a scope issue for functions that use eval to set or mutate.  This first example does not work, because eval doesn't affect the value of a global variable, even if said variable was already defined outside of the function.  My understanding is that  eval creates local variables by definition when called within a function.  function array_sort_by_item_length() {     local eval=$(php \"$CLOUDY_ROOT\/php\/helpers.php\" \"array_sort_by_item_length\" \"${array_sort_by_item_length__array[@]}\")      # note: [ $eval = 'declare -a array_sort_by_item_length__array=(\"on\" \"five\" \"three\" \"september\")' ]     # Notice the eval code aims to mutate $array_sort_by_item_length__array     # Even though $array_sort_by_item_length__array was already global, the eval doesn't not mutate the global value.      eval $eval     ... }   Here is the fix to make it work:  function array_sort_by_item_length() {     local eval=$(php \"$CLOUDY_ROOT\/php\/helpers.php\" \"array_sort_by_item_length\" \"${array_sort_by_item_length__array[@]}\")      eval $eval      # note: [ $eval = 'declare -a sorted=(\"on\" \"five\" \"three\" \"september\")' ]     # It's the following assignment here that makes it work.     array_sort_by_item_length__array=(\"${sorted[@]}\")      ... }       Name your function arguments  To make your code more readible, the first line(s) of a function should name the function arguments.  Declare them as local.  Then follow with a blank space, after which you begin the process of the function.  function get_config() {     local config_key_path=\"$1\"     local default_value=\"$2\"      # Now do the function stuff...   Next, declare local variables just below that  Group all local variable names below arguments and declare them there rather than deeper in the function where they are used.  Even if no default values, declare them here anyway.  function get_config() {     local config_key_path=$1     local default_value=\"$2\"      local name     local type=\"string\"      ...      ","tags":"","url":"conventions.html"},{"title":"Development Tools","text":"  How to use debug  This function has nothing to do with step debugging, however it gives you a consistent means to see where something happened and what a value is at a given point in the code  Example One  debug \"Stopping at this point;$0;$FUNCNAME;$LINENO\"   This will give you a nice output like this:    Or if called from within a function:  function my_function() {     debug \"Stopping at this point;$0;$FUNCNAME;$LINENO\" }      Even if not calling within a function you may pass $FUNCNAME as shown in both cases, and it will simply be ignored if irrelevent.   Example Two  This example shows how to create a label.  By separating your message and label with a single semi-colon, you will get this type of result.  Notice the $ is escaped as we want a literal dollar-sign in the label.   debug \"$WDIR;\\$WDIR\"     Example Three  This will just give you a quick message with default label:  debug \"Quick message\"     Stop execution with throw  Similar to debug, yet it stops execution immediately with an exit code of 3.  throw \"Aborting at this point;$0;$FUNCNAME;$LINENO\"    ","tags":"","url":"development.html"},{"title":"Documenting Code","text":"  Cloudy scripts should include function documentation per TomDoc syntax.  Documentation can be extracted using tomdoc.sh  Here is an example docblock.  # Prompt for a Y or N confirmation. # # $1 - The confirmation message # --caution - Use when answering Y requires caution. # --danger - Use when answering Y is a dangerous thing. # # Returns 0 if the user answers Y; 1 if not. function confirm() {     local message=\"$1\"     ...  ","tags":"","url":"documenting.html"},{"title":"Exit Status","text":"  When you call exit_with_success and exit_with_success_elapsed the exit status is set to 0 and the script exits.  With the latter, the elapsed time is also printed.  When you call exit_with_failure the exit status is set to 1 by default.  To change the exit status to something other than 1, then pass the --status={code} option, like the following, which will return a 2.  Valid exit codes are from 0-255. Learn more.  exit_with_failure --status=2 \"Missing $ROOT\/_perms.local.sh.\"   You can use throw kind of like an exception. ","tags":"","url":"error-handling.html"},{"title":"Events (Hooks)","text":"   Event handlers are functions that must be defined before the Cloudy bootstrap.  #!\/usr\/bin\/env bash  ...  # # Define all event handlers here. #  # Begin Cloudy Bootstrap s=\"${BASH_SOURCE[0]}\";while ...  To see the available events recursively search codebase for event_dispatch \".   Cloudy Core Events   pre_config compile_config boot clear_cache   on_boot  If you define this function before the bootstrap it will be called once the minimum bootstrap has been called.  To see an example of this you can look to the tests path in cloudy_installer.sh.  Example of a Custom Event  Imagine a custom event like showing info.  Let's call the event show_info.  You Cloudy script will fire or trigger the event with a line like this:  event_dispatch \"show_info\" \"do\" \"re\" \"mi\" local trigger_result=$?   How might another script respond to this event?  function on_show_info() {     local do=$1     local re=$2     local mi=$3      ... }   Listening for events  You can register custom callbacks using event_listen.  See below...  Using additional_bootstrap files  In some cases you will need to add your listeners in a custom bootstrap file which is registered in your configuration as additional_bootstrap.  They are sourced after all configuration has been loaded.  The contents of such file could look like this:  #!\/usr\/bin\/env bash  function here_we_go() {     debug \"$FUNCNAME;\\$FUNCNAME\" }  event_listen \"boot\" \"here_we_go\"  ","tags":"","url":"events.html"},{"title":"The Initialize API","text":"  If you want you may hook into the Cloudy initialize api, which normalizes the work of initializing configuration files for an instance of your Cloudy Package.   Create a folder init\/ and place all files needed during initializeation. Create a file init\/cloudypm.files_map.txt and define where the files go.  See below.   The files map  This is a text file that tells what files go where.  Basically two columns, separated by a space.  The first column lists filenames in init\/.  The second column are filenames (not directories) relative to $ROOT, or absolute.  The contents of the files map must have at least the following line; however column two dirname may be different.  The point is the asterix must be there.  * ..\/..\/..\/bin\/config\/*    The * represents all filenames in init\/.   But let's say you want one of the files to go elsewhere.  The contents of cloudypm.files_map.txt might look like this:  * ..\/..\/..\/bin\/config\/* _perms.custom.sh ..\/..\/..\/bin\/_perms.custom.sh   In this case * represents all files except for &#95;perms.custom.sh.  They are initializeed as before, however &#95;perms.custom.sh is initializeed at $ROOT\/..\/..\/..\/bin\/&#95;perms.custom.sh.  Remember you must indicate filenames, not directories.  Also, you may rename the file by indicating a different filename in column two.  Finally let's say you want to skip over a file completely; do not include a destination for it, and it will be ignored, like this  * ..\/..\/..\/bin\/config\/* _perms.custom.sh ..\/..\/..\/bin\/_perms.custom.sh ignored_file.txt   Special Handling for files named gitignore  If you create init\/gitignore (no leading dot), it will be copied to ..\/..\/..\/opt\/.gitignore.  (This is the recommended location by Cloudy Package Manager.)  However, it will be merged with an existing .gitignore file, which already exists at that location.  Do not make an entry in cloudypm.files_map.txt. ","tags":"","url":"installer.html"},{"title":"Localization\/Translation","text":"  Note: this is not available until after the configuration has been bootstrapped.  Translate or reword  You can translate or reword certain strings with this feature  translate:   ids:   - Completed successfully.   - Failed.   strings:     en:     - Installation succeeded.     - Installation failed.    The ids are the strings that appear normally. To begin a translation, copy the entire ids array as translate.strings.LANG and then alter the strings you mean to.  The value of LANG must be a two or three letter ISO 639 language code. The indexes of the ids array must match with the translate.strings.LANG array.   Implementation  To implement localization in a script, do like this:   echo_title $(translate \"Welcome to your new script!\")   Then add that to translate.ids:  translate:   ids:   - Completed successfully.   - Failed.    - Welcome to your new script!      ","tags":"","url":"localize.html"},{"title":"Logging to File","text":"  There is a file logging API built in to Cloudy.  [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_language [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_translate_en_exit_with_success [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_translate_en_exit_with_failure [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_commands_coretest_options__keys [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_commands__keys   First you must declare the filename of the log file; this enables logging.  This is relative to your script's directory and should be placed at the top of your script before the bootstrap.  LOGFILE=\"script.example.log\"  # Begin Cloudy Bootstrap s=\"${BASH_SOURCE[0]}\";while ...   These functions should be self-explanatory; each one takes a single argument, which is the message.  write_log_*   To log an error, e.g.,  write_log_error \"Cannot load file $filepath\"       The one that may require explanation is write_log, which takes one or two arguments.  When using two arguments the first is an arbitrary log label, which appears in place of the standard log levels from above.  You can set this to anything and that will allow you to filter your log items by that key using whatever log reader you're using.  Using Console in OSX is my preference.  write_log \"alpha\" \"Recording a value $value\"       You may also call it like this:  write_log \"No custom label\"  ","tags":"","url":"logging.html"},{"title":"The Script \"Operation\"","text":"  The script operation is defined as the first argument passed.  In all of the following examples it is alpha.  .\/script.example.sh alpha bravo charlie .\/script.example.sh -f alpha .\/script.example.sh --test alpha -f   If no argument is passed then the YAML configuration file may define a default operation like this:  operations:   _default: help   If the configuration file is as above, then these two are identical:  .\/script.example.sh     .\/script.example.sh help       API  get_command get_config \"operations._default\"  ","tags":"","url":"operation.html"},{"title":"The script \"options\"","text":"  Options are arguments passed to the script that begin with a single - or double -.  Here are some examples:      .\/script.example.sh -f -h -p     .\/script.example.sh -fhp     .\/script.example.sh --file=intro.txt --noup    Single hyphen options may only be one letter They may be grouped or separate. Order does not matter. Double hypen options may provide values.  ","tags":"","url":"options.html"},{"title":"Cloudy Packages","text":"  Cloudy packages are modular scripts that are meant to share a single cloudy instance across all of them.  There is a defined directory structure that must be followed for this to work.  Create a package info file  name: aklump\/perms clone_from: https:\/\/github.com\/aklump\/website-perms entry_script: perms.sh entry_symlink: perms on_install: init on_update: update    Create a file, convention names it cloudypm.yml. The name must follow vendor\/name format. The schema of the file can be seen here. The on_* are commands that will be fired at the end of that event.  They are optional. entry_symlink is optional and can be used to indicate a symlink value other than the filename of entry_script without extension.  In the above example entry_symlink is shown only for illustration.  The default value if it was omitted is perms.   Add Package to the Registry   The registry file is located here. Add the vendor\/name and a link to cloudypm.yml or cloudypm.json for your package.  These must be separated by a single space, e.g.  aklump\/perms https:\/\/raw.githubusercontent.com\/aklump\/website-perms\/master\/cloudypm.yml?token=AAZ_CajHqKkAfvJNQT5WKrtqwcYZivzGks5btjkEwA%3D%3D  You do this by cloning and creating a pull request with your addition.  ","tags":"","url":"packages.html"},{"title":"Search Results","text":" ","tags":"","url":"search--results.html"},{"title":"String Manipulation","text":"  Taken from Advanced Bash-Scripting Guide: Chapter 10. Manipulating Variables  Trim the dot from right side of string  ${string%.}   Trim the dot from left side of string  ${string#.}   Get string length  ${#string}  ","tags":"","url":"strings.html"},{"title":"Tables (Tabular Output)","text":"  You can easily create tables with Cloudy.  The following code:  echo_heading \"Tabular Data Example\" table_set_header \"Word\" \"Part of Speech\" table_add_row \"jump\" \"verb\" table_add_row \"chocolaty\" \"adjective\" table_add_row \"kitten cat\" \"noun noun\" table_add_row \"quickly\" \"adverb\" echo_table   Will produce output like the following    Control the Padding  Use the options --lpad and --rpad to control the horizontal padding.      echo_heading \"Tabular Data Example\"     table_set_header \"Word\" \"Part of Speech\"     table_add_row \"jump\" \"verb\"     ...     echo_table --lpad=10 --rpad=10    ","tags":"","url":"tables.html"},{"title":"Unit Testing","text":"  Cloudy offers a simple unit testing framework based on PhpUnit.  To see how you might implement unit tests, refer to the following files   cloudy_tools.sh and find how the command tests is handled in on_boot. tests\/cloudy.tests.sh to see how the tests themselves are written. framework\/cloudy\/inc\/cloudy.testing.sh for a list of assertions. It is optional to add the command to your config.yml file.  It's not functionally necessary, but you might do it for documentation purposes. To check if code is being run from inside a test you can use is_being_tested, e.g.:  is_being_tested &amp;&amp; ...    Setup  You will want to implement the on_boot hook if you want to run tests.  ... # Uncomment this line to enable file logging. LOGFILE=\"install\/cloudy\/cache\/cloudy_installer.log\"  function on_boot() {     [[ \"$(get_command)\" == \"tests\" ]] || return 0     source \"$CLOUDY_ROOT\/inc\/cloudy.testing.sh\"     do_tests_in \"cloudy_installer.tests.sh\"     do_tests_in ...     do_tests_in ...     exit_with_test_results } ...   Fixtures  You may use the following as test fixtures, i.e., https:\/\/phpunit.readthedocs.io\/en\/7.3\/fixtures.html?highlight=setup  setup_before_test teardown_after_test  ","tags":"","url":"testing.html"},{"title":"Script Version","text":"  To provide a version for your script other than the default 1.0, you have two options.  Version Indicated in YAML  You may hard-code the version in a YAML config file like this:  title: Cloudy Installer version: 1.5 ...   Version Indicated Dynamically  If you would rather provide your version dynamically with BASH, you can override the default get_version by adding it to your script file anytime after the bootstrap; this allows you to provide it via PHP, cat or whatever, e.g.,  ... done;r=\"$(cd -P \"$(dirname \"$s\")\" &amp;&amp; pwd)\";source \"$r\/framework\/cloudy\/cloudy.sh\" # End Cloudy Bootstrap  function get_version() {     local version=$(grep \"version = \" \"$ROOT\/web_package.info\")     echo ${version\/version = \/ } }  ","tags":"","url":"version.html"},{"title":"Writing Your First Cloudy Script","text":"  Let's say you want to create a script called imagine.sh.  Defining Your Script's Commands  To understand how to define commands, let's look at the following example.  This is taken from the script's master configuration file.  commands:   mountain:     help: Indicate the the user wants to imagine a mountain setting.     aliases:       - mt     arguments:       mountain_name:         help: The name to give to the imagined item.         required: true     options:       peaks:         help: The numbe of peaks.         aliases:           - p         type: integer   Let's break the above down into parts, but first take note that it is not enough merely to define your commands in configuration, you have to handle each command in imagine.sh as well, e.g.,  if [[ \"$(get_command)\" == \"mountain\" ]]; then ...   ... or with a case statment, e.g.,  case $(get_command) in   \"mountain\")     ...   ;;      Back to the configuration...  Indicate the command name  The most basic definition consists fo a command and a help topic:  commands:   mountain:     help: Install a Cloudy package from the Cloudy Package Registry.   If this was all that was defined in the configuration, users would only be able to enter:  .\/imagine.sh mountain   Indicate command aliases  By adding one or more command aliases, you give the user options, usually for brevity in typing.  commands:   mountain:     help: Indicate the the user wants to imagine a mountain setting.     aliases:       - mt   With this configuration the user can enter either of these two and get the same effect.  .\/imagine.sh mountain .\/imagine.sh mt   Indicate command arguments  Let's say you want to collect a mountain name, you would indicate a command argument &lt;mountain_name&gt;.  commands:   mountain:     ...     arguments:       mountain_name:         help: The name to give to the imagined mountain.   Now the user may enter any of the following, however the user who provides the mountain name will have a different response--presumably--than the one who omits it.  .\/imagine.sh mountain .\/imagine.sh mt .\/imagine.sh mountain Everest .\/imagine.sh mt Everest   Make an argument required  But what if the name is to be requried?  commands:   mountain:     ...     arguments:       mountain_name:         ...         required: true   Now the user can no longer omit the &lt;mountain_name&gt; argument.  Indicate command options  commands:   mountain:     ...     options:       peaks:         help: The numbe of peaks.         aliases:           - p         type: integer       yes:         help: Answer yes to all questions.         aliases:           - y         type: boolean   The user will now be entering any of the following:  .\/imagine.sh mt \"Three Sisters\" --peaks=3             .\/imagine.sh mt \"Three Sisters\" -p=3             .\/imagine.sh mt \"Three Sisters\" --yes -p=3             .\/imagine.sh mt \"Three Sisters\" -y -p=3              ","tags":"","url":"writing-scripts.html"}]};
