var tipuesearch = {"pages":[{"title":"Cloudy Changelog","text":"  1.0.6   BREAKING CHANGE: Renamed $parse_args__option__* to parse_args__options__*.  ","tags":"","url":"CHANGELOG.html"},{"title":"Cloudy","text":"    Summary  A lightweight BASH framework, which uses YAML or JSON for your script's configuration and provides a unit testing framework.  Cloudy Boosts the following features:   Clean configuration options (YAML, JSON) for your scripts A BASH Unit Testing framework inspired by PHPUnit Auto-generated help output Support for multilingual localization   Visit https:\/\/aklump.github.io\/cloudy for full documentation.  Quick Start  After installing Cloudy, to write a new script called thunder.sh ...   cd to the directory where you want the script to be created. Type cloudy new thunder.sh and the necessary files\/directories will be created in the current directory. Open thunder.sh and write your code. Open thunder.yml and add some configuration. To learn about the options to use with new type cloudy help new. Refer to the documentation for to learn more.   Using JSON   To work with JSON configuration instead type cloudy new thunder.sh --json.   Requirements   Works with BASH 3 PHP (Used invisibly on the backend for configuration processing; no PHP knowledge is required to use Cloudy.)   Contributing  If you find this project useful... please consider making a donation.  Installation  Installation means downloading this repository to your system.  It contains cloudy_tools.sh which is used to generate new scripts, as well as the cloudy framework.  It is a Cloudy script.  Here is a snippet to clone this repo to a directory on your system $HOME\/opt\/cloudy and create a symlink in $HOME\/bin\/cloudy.  This assumes ~\/bin is in your $PATH variable.  (cd $HOME &amp;&amp; (test -d opt || mkdir opt) &amp;&amp; (test -d bin || mkdir bin) &amp;&amp; cd opt &amp;&amp; (test -d cloudy || git clone https:\/\/github.com\/aklump\/cloudy.git) &amp;&amp; (test -s $HOME\/bin\/cloudy || ln -s $HOME\/opt\/cloudy\/cloudy_installer.sh $HOME\/bin\/cloudy)) &amp;&amp; cloudy   On success you should see something resembling the following:    Usage  Beyond the internal variables the following variables are made available by Cloudy.       varname   description       $ROOT   The directory containing your script.     $SCRIPT   Absolute path to your script.     $CONFIG   Absolute path to the base config file.     $WDIR   The working directory when script was initiated.     $LOGFILE   Absolute path to a log file, if enabled.      Learn more about BASH with the Advanced Bash-Scripting Guide. Determine your version of BASH with echo $BASH_VERSION  ","tags":"","url":"README.html"},{"title":"Tasklist","text":"  - [ ] ld--roadmap: Fix the delay caused by deleting files at beginning of compile. - [ ] ld--todos: a task list item - [ ] ld--todos: a task list item @w-10 - [ ] demos--md_extra: Todo items will get aggregated automatically @w10 - [ ] ld--todos: a task list item @w10 - [ ] ld--todos: a task list item @w10.1  ","tags":"","url":"_tasklist.html"},{"title":"This script \"arguments\"","text":"  Cloudy makes it easy to react to script arguments.  For example:  .\/install.sh dev install --tree=blue -abc   Here we have:   The script file install.sh The command command=$(get_command), e.g. dev One argument arg=$(get_arg 0), e.g., install. One value option, tree, param=$(get_param \"tree\"), e.g., blue Three boolean options: a,b,c, has_flag \"a\"   Test if an option was used  has_option b &amp;&amp; echo \"has b option\"   Access an option value  echo \"tree's value is $(get_option tree \"not set\")\"  ","tags":"","url":"arguments.html"},{"title":"Arrays","text":"  How to copy an array  new_array=(\"${old_array[@]}\")   This comes in to play after array-based functions like string_split  string_split__string=\"do&lt;br \/&gt;re&lt;br \/&gt;mi\" string_split '&lt;br \/&gt;' &amp;&amp; local words=(\"${string_split__array}\")  ","tags":"","url":"arrays.html"},{"title":"Configuration","text":"  Configuration is provided by YAML or JSON files.  Examples here will be shown with YAML.  In the header of your script you will find CONFIG, this is for the base configuration file, e.g.,      CONFIG=script.example.yml     CONFIG=script.example.config.json    Set it's value to the path of a supported file to use as configuration, absolute paths must begin with a forward slash, otherwise the path will be taken relative to the directory containing the script, i.e., $(dirname $CONFIG) You may add additional configuration files by adding something like following in the YAML of the base configuration file.  additional_config:   - _install.local.yml  You may have any number of configuration files. Consider limited file permissions on your configuration files; e.g. chmod go-rwx.   Using Config  Scalars  To get a configuration value you will use the get_config function.  The following example is the contents of an imaginary config.yml:  perms:   user: aklump   group: apache   files: 640   directories: 750   To access the perms group scalar value do one of the following:  eval $(get_config \"perms.group\" \"staff\") # [ perms_group = 'apache' ]    Notice the dot separation to denote parent\/child. The second argument is a default value, e.g., staff.   You can also assign to a different variable like this:  eval $(get_config_as \"group\" \"perms.group\" \"staff\")  # [ group = 'apache' ]   Arrays  Arrays are handled differntly depending upon a few things: if the config key points to a multi-dimensional array, an single-level associative array, or an single-level indexed array.  For examples turn to the following configuration YAML:  user:   images:     tags:     - nature     - space     - religion     types:     - jpg     - png   Let's see what $(get_config -a 'user.images.tags') returns us:  When the config key points to an array get_config echos a string ready for eval, which generates a nice set of BASH vars containing the values of perms, e.g.,  eval $(get_config perms) echo $perms_user echo $perms_group echo $perms_files echo $perms_directories   If the config key points to an indexed array, e.g., ....  Non-Scalars Keys  In a more complex configuration like the following, you might want to get the array keys, in this case all the \"operations\"; do so with get_config.  Our example will echo a string like this: declare -a config_keys=(\"_default\" \"help\" \"new\")  operations:   _default: help   help:     help: Display this help screen   new:     help: Create new Cloudy script file in the current directory     options:       config:         help: Set the basename of the config file.       force:         aliases: [f]         help: Force the overwrite of an existin file.   This is a usage example:  eval $(get_config_keys \"commands\")  ${config_keys[0]} == \"_default\" ${config_keys[1]} == \"help\" ${config_keys[2]} == \"new\"   Filepaths  Configuration values which are filepaths can be added to the YAML as relative paths:  webroot: ..\/web path_to_binaries: . public_files: ..\/web\/sites\/default\/files   Then when you access the configuration use get_config_path, e.g.,  eval $(get_config_path \"webroot\")   The value of $webroot will be an an absolute filepath.  How are relative filepaths made absolute?   By default $ROOT is used as the basepath, which is the directory that contains your Cloudy script. You can alter this behavior by setting the configuration variable as config_path_base with a value, which is either an absolute path, or a relative path, relative to $ROOT.  Both of these are valid values:  config_path_base: ..\/..\/.. config_path_base: \/Users\/aklump\/config    Pro Tip  If you put a stack of paths under a single key, like so:  files: - webroot: ..\/web - bin: . - public: ..\/web\/sites\/default\/files   You can import all of them with one line like this:  eval $(get_config_path \"files\")   And you will have access to:  $files_webroot         $files_bin         $files_public   If the yaml is an indexed array like so:  files: - ..\/web - . - ..\/web\/sites\/default\/files   You have one extra step of variable assignment.  eval $(get_config_path \"writeable_directories\") writeable_directories=($_config_values[@]})      ","tags":"","url":"configuration.html"},{"title":"Cloudy Conventions","text":"  Cloudy has some opinions about how to write code, this page reveals them.  General   Functions that begin with _cloudy should be considered private and never called by your script.  They may change in future versions. All functions listed in cloudy.sh comprise the public API and will not change across minor version changes.   Naming   Function names should be readable and intuitive, e.g., exit_with_success is better than success_exit Function names should start with a verb if applicable, unless they are grouped by category, e.g. array_join is fine because stack is the common group; join is the verb.   Boolean  Even though BASH doesn't distinguish between (bool) \"true\" and (string) \"true\", you should indicate your intention by not using quotes for boolean value.  my_var=true my_var=false   Do not do the following when your intention is boolean:  my_var=\"true\" my_var=\"false\"   Likewise to test for true do like this, which again, omits any quotes around true.  [[ \"$my_var\" = true ]]   Functions   For getters when echoing a default value, return 2   Functions that operate on arrays  When a function needs to manipulate an array, the array should be assigned to a global variable, the name of which is the function with __array added to the end, e.g.,  function array_join() {     local glue=$1     local string     string=$(printf \"%s$glue\" \"${array_join__array[@]}\") &amp;&amp; string=${string%$glue} || return 1     echo $string     return 0 }   And here is the usage  array_join__array=(\"${_config_values[@]}\") local options=\"-$(array_join \", -\"), --${option}\"       However, if a single function operates on more than one array, then the suffix should be modified as necessary.  Look at _cloudy_parse_option_arguments for a good example.  You still want the suffix to begin with two underscores.  Functions that return an array  The same naming conventions apply, if the function has to \"return\" an array, which, in BASH means it sets or mutates a global array.  Beware of a scope issue for functions that use eval to set or mutate.  This first example does not work, because eval doesn't affect the value of a global variable, even if said variable was already defined outside of the function.  My understanding is that  eval creates local variables by definition when called within a function.  function array_sort_by_item_length() {     local eval=$(php \"$CLOUDY_ROOT\/php\/helpers.php\" \"array_sort_by_item_length\" \"${array_sort_by_item_length__array[@]}\")      # note: [ $eval = 'declare -a array_sort_by_item_length__array=(\"on\" \"five\" \"three\" \"september\")' ]     # Notice the eval code aims to mutate $array_sort_by_item_length__array     # Even though $array_sort_by_item_length__array was already global, the eval doesn't not mutate the global value.      eval $eval     ... }   Here is the fix to make it work:  function array_sort_by_item_length() {     local eval=$(php \"$CLOUDY_ROOT\/php\/helpers.php\" \"array_sort_by_item_length\" \"${array_sort_by_item_length__array[@]}\")      eval $eval      # note: [ $eval = 'declare -a sorted=(\"on\" \"five\" \"three\" \"september\")' ]     # It's the following assignment here that makes it work.     array_sort_by_item_length__array=(\"${sorted[@]}\")      ... }       Name your function arguments  To make your code more readible, the first line(s) of a function should name the function arguments.  Declare them as local.  Then follow with a blank space, after which you begin the process of the function.  function get_config() {     local config_key_path=\"$1\"     local default_value=\"$2\"      # Now do the function stuff...   Next, declare local variables just below that  Group all local variable names below arguments and declare them there rather than deeper in the function where they are used.  Even if no default values, declare them here anyway.  function get_config() {     local config_key_path=$1     local default_value=\"$2\"      local name     local type=\"string\"      ...      ","tags":"","url":"conventions.html"},{"title":"Development Tools","text":"  How to use debug  This function has nothing to do with step debugging, however it gives you a consistent means to see where something happened and what a value is at a given point in the code  Example One  debug \"Stopping at this point;$0;$FUNCNAME;$LINENO\"   This will give you a nice output like this:    Or if called from within a function:  function my_function() {     debug \"Stopping at this point;$0;$FUNCNAME;$LINENO\" }      Even if not calling within a function you may pass $FUNCNAME as shown in both cases, and it will simply be ignored if irrelevent.   Example Two  This example shows how to create a label.  By separating your message and label with a single semi-colon, you will get this type of result.  Notice the $ is escaped as we want a literal dollar-sign in the label.   debug \"$WDIR;\\$WDIR\"     Example Three  This will just give you a quick message with default label:  debug \"Quick message\"     Stop execution with throw  Similar to debug, yet it stops execution immediately with an exit code of 3.  throw \"Aborting at this point;$0;$FUNCNAME;$LINENO\"    ","tags":"","url":"development.html"},{"title":"Exit Status","text":"  When you call exit_with_success and exit_with_success_elapsed the exit status is set to 0 and the script exits.  With the latter, the elapsed time is also printed.  When you call exit_with_failure the exit status is set to 1 by default.  To change the exit status to something other than 1, then pass the --status={code} option, like the following, which will return a 2.  Valid exit codes are from 0-255. Learn more.  exit_with_failure --status=2 \"Missing $ROOT\/_perms.local.sh.\"   You can use throw kind of like an exception. ","tags":"","url":"error-handling.html"},{"title":"Events","text":"   Event handlers are functions that must be defined before the Cloudy bootstrap.  #!\/usr\/bin\/env bash  ...  # # Define all event handlers here. #  # Begin Cloudy Bootstrap s=\"${BASH_SOURCE[0]}\";while ...  To see the available events look at framework\/cloudy.events.sh.   on_boot  If you define this function before the bootstrap it will be called once the minimum bootstrap has been called.  To see an example of this you can look to the tests path in cloudy_installer.sh. ","tags":"","url":"events.html"},{"title":"Localization\/Translation","text":"  Translate or reword  You can translate or reword certain strings with this feature  translate:   ids:   - Completed successfully.   - Failed.   strings:     en:     - Installation succeeded.     - Installation failed.    The ids are the strings that appear normally. To begin a translation, copy the entire ids array as translate.strings.LANG and then alter the strings you mean to.  The value of LANG must be a two or three letter ISO 639 language code. The indexes of the ids array must match with the translate.strings.LANG array.   Implementation  To implement localization in a script, do like this:   echo_title $(translate \"Welcome to your new script!\")   Then add that to translate.ids:  translate:   ids:   - Completed successfully.   - Failed.    - Welcome to your new script!      ","tags":"","url":"localize.html"},{"title":"Logging to File","text":"  There is a file logging API built in to Cloudy.  [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_language [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_translate_en_exit_with_success [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_translate_en_exit_with_failure [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_commands_coretest_options__keys [Tue Sep 11 18:16:24 PDT 2018] [debug] Using filesystem to obtain config: cloudy_config_commands__keys   First you must declare the filename of the log file; this enables logging.  This is relative to your script's directory and should be placed at the top of your script before the bootstrap.  LOGFILE=\"script.example.log\"  # Begin Cloudy Bootstrap s=\"${BASH_SOURCE[0]}\";while ...   These functions should be self-explanatory; each one takes a single argument, which is the message.  write_log_*   To log an error, e.g.,  write_log_error \"Cannot load file $filepath\"       The one that may require explanation is write_log, which takes one or two arguments.  When using two arguments the first is an arbitrary log label, which appears in place of the standard log levels from above.  You can set this to anything and that will allow you to filter your log items by that key using whatever log reader you're using.  Using Console in OSX is my preference.  write_log \"alpha\" \"Recording a value $value\"       You may also call it like this:  write_log \"No custom label\"  ","tags":"","url":"logging.html"},{"title":"The Script \"Operation\"","text":"  The script operation is defined as the first argument passed.  In all of the following examples it is alpha.  .\/script.example.sh alpha bravo charlie .\/script.example.sh -f alpha .\/script.example.sh --test alpha -f   If no argument is passed then the YAML configuration file may define a default operation like this:  operations:   _default: help   If the configuration file is as above, then these two are identical:  .\/script.example.sh     .\/script.example.sh help       API  get_command get_config \"operations._default\"  ","tags":"","url":"operation.html"},{"title":"The script \"options\"","text":"  Options are arguments passed to the script that begin with a single - or double -.  Here are some examples:      .\/script.example.sh -f -h -p     .\/script.example.sh -fhp     .\/script.example.sh --file=intro.txt --noup    Single hyphen options may only be one letter They may be grouped or separate. Order does not matter. Double hypen options may provide values.  ","tags":"","url":"options.html"},{"title":"Cloudy Packages","text":"  Create a package info file  name: aklump\/perms clone_from: https:\/\/github.com\/aklump\/website-perms entry_script: perms.sh on_install: install on_update: update    The name must follow vendor\/name format. The schema of the file can be seen here. The on_* are commands that will be fired at the end of that event.  They are optional.   Add Package to the Registry   The registry file is located here. Add the vendor\/name and a link to cloudypm.yml or cloudypm.json for your package.  These must be separated by a single space, e.g.  aklump\/perms https:\/\/raw.githubusercontent.com\/aklump\/website-perms\/master\/cloudypm.yml?token=AAZ_CajHqKkAfvJNQT5WKrtqwcYZivzGks5btjkEwA%3D%3D  You do this by cloning and creating a pull request with your addition.  ","tags":"","url":"packages.html"},{"title":"Search Results","text":" ","tags":"","url":"search--results.html"},{"title":"String Manipulation","text":"  Taken from Advanced Bash-Scripting Guide: Chapter 10. Manipulating Variables  Trim the dot from right side of string  ${string%.}   Trim the dot from left side of string  ${string#.}   Get string length  ${#string}  ","tags":"","url":"strings.html"},{"title":"Tables (Tabular Output)","text":"  You can easily create tables with Cloudy.  The following code:  echo_heading \"Tabular Data Example\" table_set_header \"Word\" \"Part of Speech\" table_add_row \"jump\" \"verb\" table_add_row \"chocolaty\" \"adjective\" table_add_row \"kitten cat\" \"noun noun\" table_add_row \"quickly\" \"adverb\" echo_table   Will produce output like the following    Control the Padding  Use the options --lpad and --rpad to control the horizontal padding.      echo_heading \"Tabular Data Example\"     table_set_header \"Word\" \"Part of Speech\"     table_add_row \"jump\" \"verb\"     ...     echo_table --lpad=10 --rpad=10    ","tags":"","url":"tables.html"},{"title":"Unit Testing","text":"  Cloudy offers a simple unit testing framework based on PhpUnit.  To see how you might implement unit tests, refer to the following files   cloudy_installer.sh and find how the command tests is handled. cloudy_installer.tests.sh to see how the tests themselves are written. cloudy.sh for a list of assertions.   Setup  You will want to implement the on_boot hook if you want to run tests.  ... # Uncomment this line to enable file logging. LOGFILE=\"install\/cloudy\/cache\/cloudy_installer.log\"  function on_boot() {     [[ \"$(get_command)\" == \"tests\" ]] || return 0     source \"$CLOUDY_ROOT\/inc\/cloudy.testing.sh\"     do_tests_in \"cloudy_installer.tests.sh\"     do_tests_in ...     do_tests_in ...     exit_with_test_results } ...   Fixtures  You may use the following as test fixtures, i.e., https:\/\/phpunit.readthedocs.io\/en\/7.3\/fixtures.html?highlight=setup  setup_before_test teardown_after_test  ","tags":"","url":"testing.html"},{"title":"Script Version","text":"  To provide a version for your script other than the default 1.0, you have two options.  Version Indicated in YAML  You may hard-code the version in a YAML config file like this:  title: Cloudy Installer version: 1.5 ...   Version Indicated Dynamically  If you would rather provide your version dynamically with BASH, you can override the default get_version by adding it to your script file anytime after the bootstrap; this allows you to provide it via PHP, cat or whatever, e.g.,  ... done;r=\"$(cd -P \"$(dirname \"$s\")\" &amp;&amp; pwd)\";source \"$r\/framework\/cloudy\/cloudy.sh\" # End Cloudy Bootstrap  function get_version() {     local version=$(grep \"version = \" \"$ROOT\/web_package.info\")     echo ${version\/version = \/ } }  ","tags":"","url":"version.html"}]};
